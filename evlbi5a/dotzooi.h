// utilities for dealing with DOT [D(ata) O(bserving) T(ime)]
// Copyright (C) 2007-2008 Harro Verkouter
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// any later version.
// 
// This program is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
// PARTICULAR PURPOSE.  See the GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 
// Author:  Harro Verkouter - verkouter@jive.nl
//          Joint Institute for VLBI in Europe
//          P.O. Box 2
//          7990 AA Dwingeloo
#ifndef JIVE5A_DOTZOOI_H
#define JIVE5A_DOTZOOI_H

#include <map>
#include <string>
#include <timewrap.h>
#include <ezexcept.h>
#include <ioboard.h>


// Declare a DOT-exception
DECLARE_EZEXCEPT(dotclock)

// 1 Feb 2013: HV - rewrote the DOT-clock handling.
//
// In the old version we only kept an offset of the
// DOT clock to the O/S time, completely ignorning 
// the DOT1PPS interrupts being generated by the 
// Mark5B I/O card.
//
// Reports from the field (thanks Jonathan Quick,
// HartRAO) mention that this doesn't work if
// e.g. the maser is failing or the computer's
// system clock is drifting.
//
// In the new system we do DOT timekeeping as follows:
//
// * at startup an 'interrupt handler' should be started
//   using dotclock_init(). This configures the hardware
//   to generate the 1PPS's to the kernel and subsequently
//   to jive5ab. An 'interrupt handler' thread is started.
//
// * At each DOT1PPS from the I/O board the DOT clock
//   is incremented by exactly 1 second - IF the 
//   time has been set using "dot_set=..."
//   If the DOT has not been set the time is 
//   00h00m on Jan 1 1970 and is NOT incremented so
//   the current DOT will always read this value.
//   Also the kernel time of the interrupt  will
//   be saved in the 'last_1pps' variable. (this
//   value is part of the return value of the 
//   'wait-for-interrupt' ioctl(2) on the 
//   Mark5B I/O board driver filedescriptor)
//
// * set_dot( /* requested DOT */ ) will set up
//   the system such that the requested DOT will be
//   transferred to the actual DOT clock at the 
//   next DOT1PPS. The dot_set() routine records
//   the time at which it issued the request.
//
//   At the next DOT1PPS the 'interrupt handler' 
//   computes the time difference between the 
//   time issued and the time it actually set the 
//   requested DOT.
//   This value is retrieved via the "dot_set?" 
//   query [see Mark5B-DIM-Commandset1.12.pdf]
//   (which calls the "get_set_dot_delay()".
//
//   set_dot() ONLY allows setting integral second
//   values of DOT clock!
//
//   The interrupt handler resets the request-new-DOT 
//   status after having processed the request.
//
//   Fails with "false" if the DOT clock isn't running
//   yet. Before the I/O board starts generating interrupts
//   it must have (1) a 1PPS source and (2) a clock_set=
//
// * dot_get() returns a 'tuple' (a struct in this
//   prgrmmng language) with the current DOT and
//   the O/S time at the time of requesting the DOT.
//   This allows the caller to compare the exact
//   difference between DOT and O/S and will allow
//   it to be monitored. 
//   The DOT is computed as follows:
//     * get the current O/S time
//     * get the current DOT (which was the last
//       integer second tick!)
//     * get the time of the last DOT1PPS tick
//     * compute how much time has elapsed between
//       the current O/S time and the time of the
//       last DOT1PPS tick, add this delta to
//       the current DOT second to get the full
//       DOT at the current moment
//
// NOTE: all access to shared data is
//       properly sequenced using a mutex


// Increment the DOT clock by 'nsec' seconds - can be
// positive or negative. Will return false if dot clock
// not running yet! (ie no dot_set= performed).
// Throws exception if can't lock/unlock the mutex.
bool inc_dot(int nsec);

// will parse time_text into result, time text should be of the form:
// <n>y<n>d<n>h<n>m<f>s, where values may be omitted from the big end
// returns the number of fields parsed
unsigned int parse_vex_time( std::string time_text, struct ::tm& result, unsigned int& microseconds );

// zero based seconds in year
unsigned int seconds_in_year(struct tm& tm);

// New DOTCLOCK API
void dotclock_init(ioboard_type& iob);
void dotclock_cleanup( void ) ;

// Instruct the dot clock to set the requested dot at the next 1PPS.
// Later you can retrieve how long it took the system to honour the
// request via the 'get_set_dot_delay()'
bool   set_dot(const pcint::timeval_type& reqdot);
double get_set_dot_delay( void );

struct dot_type {
    pcint::timeval_type  dot;
    pcint::timeval_type  lcl;

    dot_type(const pcint::timeval_type& d, const pcint::timeval_type& l);
};

// get current dot + the O/S time at the time
dot_type get_dot( void );

#endif
