
// The threadid variables are (to be) protected with a mutex
// so, before tinkering with them, acquire the mutex, then tinker
// and finally release them
pthread_t*      readthread = 0;
pthread_t*      writethread = 0;
pthread_mutex_t thrdidmtx = PTHREAD_MUTEX_INITIALIZER;

// Join the threads and clean up the global variables and
// release the memory associated with those.
void join_threads( void ) {
    ASSERT_ZERO( ::pthread_mutex_lock(&thrdidmtx) );

    if( readthread )
        ::pthread_join( *readthread, 0 );
    if( writethread )
        ::pthread_join( *writethread, 0 );
    delete readthread;
    delete writethread;
    readthread  = 0;
    writethread = 0;
    ASSERT_ZERO( ::pthread_mutex_unlock(&thrdidmtx) );
    return;
}

// Start two threads of execution with 'rd' and 'wr' in them respectively
// The 'argptr' is the (optional) thread-function argument pointer
// Both threads will be run with the same argumentptr.
//
// Note: thread-fn authors should make sure that
// the synchronization is ok; at this point we don't bother.
// We just run 'm.
//
// if anything fails, an exception thrown, otherwise the function
// "just succeeds".
void start_threads( void* (*rd)(void*), void* (*wr)(void*), void* argptr = 0 ) {
    sigset_t       oldset, newset;
    pthread_attr_t attribs;

    DEBUG(3,"Killing threads...");
    join_threads();
    DEBUG(3,"Ok"<< endl);

    // Before creating the threads, set the sigmask to empty (saving the
    // current set) and restore the mask afterwards. Threads that are
    // being created inherit the mask of the thread starting them so this
    // is the most convenient way to do it [otherwise we'd have to put
    // this code in each thread-function]
    ASSERT_ZERO( ::sigfillset(&newset) );
    ASSERT_ZERO( ::pthread_sigmask(SIG_SETMASK, &newset, &oldset) );

    // Fill in the attributes we want to start the threads with
    ASSERT_ZERO( ::pthread_attr_init(&attribs) );
    // make sure we create them joinable so we can wait on them when
    // cancelled!
    //ASSERT2_ZERO( ::pthread_attr_setdetachstate(&attribs, PTHREAD_CREATE_DETACHED),
    ASSERT2_ZERO( ::pthread_attr_setdetachstate(&attribs, PTHREAD_CREATE_JOINABLE),
                  ::pthread_attr_destroy(&attribs); ::pthread_sigmask(SIG_SETMASK, &oldset, 0); );

    // finally, store the threadids in the read/write-pthread_t variables
    ASSERT_ZERO( ::pthread_mutex_lock(&thrdidmtx) );

    // Attempt to start the read-thread.
    readthread = new pthread_t;
    ASSERT2_ZERO( ::pthread_create(readthread, &attribs, rd, argptr),
                      delete readthread; readthread=0; ::pthread_attr_destroy(&attribs);
                      ::pthread_sigmask(SIG_SETMASK, &oldset, 0); );


    // ok, carry on, try to start the write thread
    writethread = new pthread_t;
    ASSERT2_ZERO( ::pthread_create(writethread, &attribs, wr, argptr),
                     delete writethread; writethread=0;
                     ::pthread_attr_destroy(&attribs); ::pthread_sigmask(SIG_SETMASK, &oldset, 0); );

    ASSERT_ZERO( ::pthread_mutex_unlock(&thrdidmtx) );

    // Done. clean up
    ::pthread_attr_destroy(&attribs);

    // and restore old sigmask
    ASSERT_ZERO( ::pthread_sigmask(SIG_SETMASK, &oldset, 0) );
    return;
}

// The threads get passed this structure
struct thrdargs_type {
    int              fd;
    unsigned int     n_empty;
    unsigned int     n_full;
    xlrdevice        xlrDev;
    // Use the conditionvariable+mutex for
    // both start/stop conditions as well
    // as "emulating" a semaphore.
    // The mutex is used to protect the
    // 'n_empty' and 'n_free' values
    // (which is ok, since a semaphore is nothing more
    // than a mutex bundled together with an int)
    // By using the condition variable, all three threads
    // involved (reader, writer and main()) can indicate to the
    // others that something needs to be done
    // thread mainloops should basically do:
    // while( true ) {
    //      pthread_condwait(condition, mtx);
    //      // check start, run, n_empty, n_full
    //      // to see if/what needs to be done
    // }
    //
    //  run==true gets set after a succesfull call to "<transfer>=on"
    //  stop==true gets set after a "<transfer>=disconnect"
    volatile bool    run;
    volatile bool    stop;
    pthread_cond_t*  condition;
    pthread_mutex_t* mtx;
    // (optional) playpointers for start,end +
    // repeat indicator.
    bool             repeat;
    playpointer      pp_start;
    playpointer      pp_end;

    thrdargs_type():
        fd( -1 ), n_empty( 0 ), n_full( 0 ), run( false ), stop( false ),
        condition( 0 ), mtx( 0 ), repeat( false )
    {}

    private:
        // really, we should not [be able to] copy/assign these babies.
        thrdargs_type( const thrdargs_type& );
        const thrdargs_type& operator=( const thrdargs_type& );
};
