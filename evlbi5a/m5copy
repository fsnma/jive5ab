#!/usr/bin/env python
# Copy data between different machines running jive5a(b(c))
import socket, time, sys, math, copy, itertools, pydoc, re, os, datetime

############################
## Support for 'enums'
##
## X = enum("AAP", "NOOT")
##
## var = X.AAP
##  ...
## if var == X.AAP:
##     ...
############################

class enum(object):
    def __init__(self, *seq):
        self.enums = seq
        for e in self.enums:
            setattr(self, e, e)

    # you can iterate over the enum to find out all defined values
    def __iter__(self):
        class enumiter(object):
            def __init__(self,enuminst):
                self.iterable = enuminst
                self.iter     = iter(enuminst.enums)
            def next(self):
                return getattr(self.iterable, self.iter.next())
        return enumiter(self)

    def __getitem__(self, idx):
        if idx in self.enums:
            return idx
        raise IndexError,"{0} does not exist".format(idx)

## take a list of (pattern, replacement) tuples and run them 
## over the string to produce the final edited string
subber   = lambda acc, (pat, repl): re.sub(pat, repl, acc)
sub      = lambda txt, lst: reduce(subber, lst, txt)

## expands string "1:10,13,20:22" into [1,2,3,4,5,6,7,8,9,10,13,20,21,22]
##   and "5:2" into [5,4,3,2]
##
## Supports arbitrary increments
##    1:10:2 => [1,3,5,7,9]
## Support arithmetic:
##  "2*10:3*10,12-2:12+2"
##  All expressions will be converted to int after evaluating
def expand_string_range(s, rchar=":"):
    rxNum = re.compile(r"^\d+$")
    rxRng = re.compile(r"^(?P<s>[-\d\.+*/%()]+)"+rchar+"(?P<e>[-\d\.+*/%()]+)(:(?P<step>[-+]?\d+))?$")
    def count_from_to(s,e,step):
        while abs(s-e)>=abs(step):
            #print "s:{0} e:{1} diff:{2}".format(s, e, abs(s-e))
            yield s
            s = s + step
        if abs(s-e)<=abs(step):
            yield s
        raise StopIteration
    def mkcounter(item):
        mo = rxRng.match(item)
        if mo:
            # start, end may be expressions
            (s,e) = (int(eval(mo.group('s'))), int(eval(mo.group('e'))))
            defstep = 1 if (s<e) else -1
            step    = mo.group('step')
            step    = int(step) if step else defstep
            # Test if we actually *can* count from start -> end using step:
            # e.g.:    1 -> 10, step -1 isn't going to end very well is it?
            #         -1 -> -10, step 1         ,,           ,,
            # Step size "0" is ONLY allowed if start==end!
            # Also assure ourselves that the step direction and counting
            # direction are identical
            if (not step and (s-e)) or (((e-s) * step )<0):
                raise RuntimeError,"cannot count from {0} to {1} with step {2}".format(s, e, step)
            return count_from_to(s, e, step)
        else:
            mo = rxNum.match(str(eval(item)))
            if not mo:
                raise ValueError, "{0} is not a number! (It's a free man!)".format(item)
            # 'item' may be an expression!
            item = int(eval(item))
            # Note: seems superfluous to return a counter for 1 number but now
            # we have a list of iterables which can easily be transformed into
            # one list via itertools.chain() (see below)
            return count_from_to(item, item, 1)
    return list(itertools.chain(*[mkcounter(x) for x in s.split(",")]))


# given a number + unit, return number between 1.0 and scale +prefix+unit
#  ie.  1024000 "Byte" => "1000 kByte"
def sciprint(num, unit, scale=1000, fmt=".2f"):
    if num<1.0:
        prefixes = ["m", "u", "n", "f", "p", ""] 
        fn       = lambda (n, p), pfx: (n*scale, pfx) if n<1.0 and (n*scale!=n) else (n, p)
    else:
        prefixes = ["k", "M", "G", "T", "P", "E"]
        fn       = lambda (n, p), pfx: (n/scale, pfx) if n>scale else (n, p)
    (n, p) = reduce(fn, prefixes, (float(num), ""))
    return "{0:{n_fmt}} {1}{2}".format(n, p, unit, n_fmt=fmt)



def progress_print(x):
    sys.stdout.write(x)
    sys.stdout.flush()

## A function returning a nice progress update including a bar + percentage, a la scp(1)
def progress(cur, s, e, sz):
    frac = (float(cur - s)/float(e - s))
    pos  = int( frac * sz )
    if pos==0:
        pos = 1
    return "Progress |" + "="*(pos-1) + ">" + " "*(sz-pos)+"| {0:6.2f}%".format(frac*100)


class Progress(object):
    def __init__(self, size):
        self.now       = datetime.datetime.now
        self.size      = size
        self.lastTime  = self.now()
        self.lastCount = 0

    def __call__(self, current, start, end):
        now   = self.now()
        count = (current - start)
        speed = (count - self.lastCount) / (now - self.lastTime).total_seconds()
        progress_print( progress(current, start, end, self.size)+" "+sciprint(speed, "byte/s", 1024)+" "*10+"\r" )
        self.lastTime  = now
        self.lastCount = count

    def done(self):
        progress_print(" "*85+"\r")

############################################################################
## Defaults for the transfer: standard TCP protocol, Mark5 control,data port
############################################################################

mtu         = 1500
nthread     = 1
queries     = False
verbose     = False
protocol    = "tcp"
dataport    = 2630
controlport = 2620
uri_type    = enum("SRC", "DST")
media_type  = enum("FILE", "DISK", "VBS")
bank_type   = enum("A", "B")


def usage():
    pydoc.pager( 
"""
Usage: {progname} [-h] [-udt] [-p <data port>] [-m <mtu>] SRC DST

Copy VLBI data from SRC to DST. Both SRC and or DST may be located on remote
machines; the default is to address data on the local machine. There is a
possibility to force the data over a different network in case there exists a
different/faster network between the SRC and DST machines than the control
network. Please find examples at the end of the documentation.

    -h        this message
    -v        be verbose, display progress (default: {def_verbose})
    -udt      use UDT as protocol (default: {def_proto})
    -p <port> use this port number for data channel
              (default: {def_data_port})
    -m <mtu>  use this MTU (default: {def_mtu})
              Note: only used when using UDT!
    -n <num>  use <num> parallel chunk transfers when doing
              flexbuff => flexbuff transfers (default: {def_nthread})

    SRC, DST: uri-like VLBI data locations. Supported formats:

    mk5://[host][:port][:dataip][/BANK|VSN]/<scan id>
        This addresses a scan on a Mark5 disk pack.

        For SRC uri the <scan id> may be a name number or a comma-
            separated list of numbers or range of numbers: 1-10,13,14.
            The name may contain the wildcard characters '*' or '?' -
            all scan names matching the pattern will be transferred.

        For DST uri the <scan id> will ONLY be interpreted as name;
            we cannot force the scan id number - it depends on what
            is already recorded on the target disk pack. If the name
            happens to be numeric, your scan will be called that.

        The BANK may be provided as "A" or "B" (case insensitive) but is
        optional. If nothing is specified the current active bank on the
        Mark5 will be used.
        
        If something is specified for BANK|VSN and it's not "A" or "B", the
        string will be interpreted as VSN. An error will happen if the given
        VSN cannot be found/switched to on the indicated Mark5.

    file://[host][:port][:dataip]/path/to/(file|dir/)
        Addresses a file or directory on disk (trailing slash means directory).

        In SRC file URIs wildcards '*' and '?' are allowed. SRC file URIs
        may never address a directory. DST file URIs _MUST_ name a directory
        IF the source consists of multiple files/scans.

    vbs://[host][:port][:dataip]/[recording]
        Addresses a vlbi_streamer (vbs) recording on a FlexBuff.
        VBS -> VBS transfers are an 'rsync' operation rather than a
        copy. Therefore some restrictions apply for those transfers.

        In SRC vbs URIs the recording MUST be specified and wildcard
        expansion is only allowed on the local machine.

        On DST vbs URIs, the "[:dataip]" is not supported. The recording
        name may only be set if the data source is 'mk5://' or 'file://'

    The "host" and "port" fields are for the CONTROL channel - the program
    will send the VSI/S formatted commands to that address. "dataip"
    should only be present in the SRC uri, it is optional and will be the
    destination ip/host address the data channel will connect to. Typically
    used to force data over a faster network on systems with >1 network
    card.

    Defaults are:
        host        localhost/127.0.0.1
        port        {def_ctrl_port}
        dataip      DST::host (i.e. the destination control ip/host)


EXAMPLES

    On a Mark5, copy scan 1-10 from local disk => local file ("disk2file").
    Each scan will end up in "/data/<scanname>.m5a":

        m5copy mk5:///1-10 file:///data/

    You can force the scans of a specific experiment to be read from a
    specific VSN:

        m5copy mk5:///cmva-007/ek035* file:///data/

    Or from a specific bank:

        m5copy mk5:///B/*ef* file:///data/

    Do a file server => Mark5 copy, forcing data to to a specific VSN,
    "file2net2disk". Each file will become a new scan on the disk pack with
    the name of the file with its extension removed:

        m5copy file:///data/gr* mk5://10.88.0.50/jod+017/

    Do a remote disk2file; i.e. trigger a local disk2file on a Mark5 from
    e.g. your control computer ("remote disk2file"):

        m5copy mk5://10.88.0.50/1-10 file://10.88.0.50/data/

    Push data from a specified VSN loaded in a remote Mark5 to a directory
    on a remote file server. Assume the Mark5 and file server's "control"
    IPv4 addresses are on the 10.88.0.* subnet and there is a high-speed
    data link between the Mark5 and the file server over a different IPv4
    subnet, 192.42.120.*. The file server has IPv4 addresses
    10.88.0.22 (control) and 192.42.120.110 (fat data pipe).

    Using this form of m5copy ensures the data will go over the fast
    192.42.120.* network whilst the control commands are sent over the
    normal network, "disk2net2file". The SRC jive5ab will be told to open
    the data connection to "dataip=192.42.120.110":

        m5copy mk5://10.88.0.50::192.42.120.110/ file://10.88.0.22/data/


""".format(progname=sys.argv[0], def_proto=protocol, def_data_port=dataport, \
           def_ctrl_port=controlport, def_mtu=mtu, def_verbose=verbose, \
           def_nthread=nthread) )


# One-liner to split a list of things into two lists, one satisfying the predicate, the other not
partition = lambda p, l: reduce(lambda (y,n), x: (y+[x], n) if p(x) else (y, n+[x]), l, ([], []))

######
# Utils
######


# will always resolve to IPv4 address such that 
# user can mix names/ip-addresses and the system will
# still compare them equal (provided they resolve to
# the same IPv4 address, of course)
def resolve_ip(host_or_ip):
    # the socket.getaddrinfo returns a list of 5-element tuples
    # we only want the IPv4 address out of the 5th element ("(ip, port)")
    # and we default to the first returned entry for the host
    try:
        return socket.getaddrinfo(host_or_ip, 0, socket.AF_INET, socket.SOCK_STREAM)[0][4][0]
    except:
        print "Failed to resolve the following name '{0}'".format(host_or_ip)
        raise 


rxBytenum   = re.compile(r"^(?P<sign>\+)?(?P<amount>[0-9]+)(?P<scale>[kMG])?$")
scaleTable = {'k': 1024, 'M':1024*1024, 'G': 1024*1024*1024}

def procByte(bn):
    mo = rxBytenum.match(bn)
    if not mo:
        raise RuntimeError, "{0}: invalid byte number".format(bn)
    # passed the regex test, now we can do stuff
    amount = int(mo.group('amount'))
    scale  = mo.group('scale')
    sign   = mo.group('sign')
    if scale:
        amount *= scaleTable[scale]
    return (sign if sign else '')+str(amount)


class URI(object):
    ## define a static method - the URI factory
    @staticmethod
    def makeURI(src_or_dst, media):
        if src_or_dst==uri_type.SRC:
            return SourceURI(media, src_or_dst)
        elif src_or_dst==uri_type.DST:
            return DestURI(media, src_or_dst)
        else:
            raise ValueError, "Cannot create neither a source or dest URI type"

    def __init__(self, media, src_or_dst):
        self.direction   = src_or_dst
        # who to talk to
        self.controlIP   = None
        self.controlPort = None

        # will be "media_type.FILE" or "media_type.DISK"
        if not media in media_type:
            raise RuntimeError, "Unrecognized media type '{0}'".format(media)
        self.mediaType   = media

        # contents of path will depend on 
        # media type
        self.path        = None

    def get_direction(self):
        return self.direction

    def __str__(self):
        # do we have these attributes?
        haveSE  = (hasattr(self,'startByte') and hasattr(self, 'endByte'))
        # are any of these not None?
        needSE  = haveSE and (self.startByte or self.endByte)
        # then we possibly need to tag them on
        seBytes = (":"+ (self.startByte if self.startByte else "") + ":" + (self.endByte if self.endByte else "")) if needSE else ''
        return "{0}::{1} [{2}:{3}{4}] {5}{6}{7}".format(self.direction, self.mediaType, self.controlIP, self.controlPort, \
                                                (":"+(self.dataIP if self.dataIP else "<dst control>") if hasattr(self,'dataIP') else ""), \
                                                ((self.bank+"/" if self.bank else "") if hasattr(self, 'bank') else ""), self.path, \
                                                seBytes)

    def parseStartEndByte(self, sb, eb):
        # if any of the start/end bytes are set and we
        # do not have one of the attributes ... 
        if (sb or eb) and not (hasattr(self, 'startByte') and hasattr(self, 'endByte')):
            raise RuntimeError, "{0} does not support configuring start and/or end byte number".format(str(self))

        if sb: 
            self.startByte = procByte(sb)
        
        if eb:
            self.endByte = procByte(eb)

class SourceURI(URI):
    def __init__(self, media, src_or_dst):
        super(SourceURI, self).__init__(media, src_or_dst)
        self.dataIP      = None

        # Some URIs support start, end byte
        # These will be *functions* which both will be 
        # passed the current start and end byte of the scan
        # being processed such they can do the appropriate offset
        # magic (eg negative numbers work from the end etc),
        # but always only on data source(s)
        self.startByte   = None
        self.endByte     = None

        if self.mediaType==media_type.DISK:
            self.bank    = None
            self.VSN     = None



class DestURI(URI):
    def __init__(self, media, src_or_dst):
        super(DestURI, self).__init__(media, src_or_dst)

        if self.mediaType==media_type.DISK:
            self.bank    = None
            self.VSN     = None


rxDisk = re.compile(r"^mk5:")
rxFile = re.compile(r"^file:")
rxVBS  = re.compile(r"^vbs:")

## For URI parsing we must know if we're parsing source or destination
## URI's. 'src_or_dst' is an 'enum' (see below)
def parseURI(uri, src_or_dst):
    if rxDisk.match(uri):
        return parseDisk(uri, src_or_dst)
    elif rxFile.match(uri):
        return parseFile(uri, src_or_dst )
    elif rxVBS.match(uri):
        return parseVBS(uri, src_or_dst )
    else:
        raise ValueError, "Unrecognized URI '{0}'".format(uri)


## Not loosely modelled after jive5ab's OPTARG macro, honestly .... ;-)
def OPTARG(lst, n, default=None):
    try:
        return lst[n] if len(lst[n]) else default
    except IndexError:
        return default


# supported:
#  mk5://[host][:port][:dataip]/[BANK|VSN/]<scanname:scanids>[:[<start>][:<end>|+<amount>]]
# So, before the first "/" is all kind of host/ip/port crap.
# note that "[:dataip]" is only supported on source URIs
def parseDisk(uri_org, src_or_dst):
    uri = re.sub("^mk5:", "", uri_org)
    rv = URI.makeURI(src_or_dst, media_type.DISK)

    # the host/port/dataip is between the leading double slash and the third
    # slash
    mo = re.match(r"^//([^/]*)/", uri)
    if not mo:
        raise RuntimeError, "{0}: invalid - does not match //.../".format(uri_org)
    hoststuff = mo.group(1)

    # now that we have matched the hoststuff out of it, we can take it out
    # of the URI
    path = re.sub(r"^//[^/]*/", "", uri)

    # any slashes remaining in the path means that a bank/vsn was passed
    slashed = path.split("/")
    if len(slashed)>2:
        raise RuntimeError, "{0}: invalid - too many slashes in bank/scan part".format(uri_org)

    # the last part is always the scanid/number
    # On a source disk, we MUST have a scan name, on DST it *may* be a scan name
    b, p = (None, None)
    if len(slashed)==2:
        (b, p) = slashed
    else:
        p = path

    # Did anyone mention start/end byte?
    p_split = p.split(':')
    rv.path = p_split[0]  # path is always the first bit

    if rv.direction==uri_type.SRC:
        if not rv.path:
            raise RuntimeError, "{0}: source URI MUST have a scan name/id".format(uri_org)

    # if there's a leading part, it's the bank/vsn
    if b:
        b = b.upper()
        if not b in bank_type:
            # must be VSN then
            if hasattr(rv, 'VSN'):
                rv.VSN = b
            else:
                raise RuntimeError, "{0}: media type {1} does not support setting VSN to {2}".format(uri_org, rv.mediaType, b)
        else:
            if hasattr(rv, 'bank'):
                rv.bank = b
            else:
                raise RuntimeError, "{0}: media type {1} does not support setting bank to {2}".format(uri_org, rv.mediaType, b)

    # Now parse the host/port stuff
    colonized = hoststuff.split(':')

    # Length check - at most three entries
    if len(colonized)>3:
        raise RuntimeError, "{0}: invalid 'host:port:dataip' part".format(uri_org)

    # Because we have the ":"'s separating the entries we only need to
    # verify if they exist at all
    rv.controlIP   = resolve_ip(OPTARG(colonized, 0, "localhost"))
    rv.controlPort = OPTARG(colonized, 1, controlport)
    if rv.controlPort:
        rv.controlPort = int(rv.controlPort)

    # Only source-type URI's parse the data ip;
    # so we only set the value if the URI object _has_ that
    # attribute
    dataip = OPTARG(colonized, 2)
    if dataip:
        if hasattr(rv, 'dataIP'):
            rv.dataIP = resolve_ip(dataip)
        else:
            raise RuntimeError, "{0} does support setting of dataip ({1})".format(uri_org, src_or_dst)

    # Save the start/end byte number parsing for last such that the URI is filled in
    rv.parseStartEndByte( OPTARG(p_split, 1), OPTARG(p_split, 2) )
    return rv


## Supported:  (the leading "file:" has already been stripped)
##  file://[host][:port][:dataip]/path/to/file[:[<start>][:<end>|+<amount>]]
# note that "[:dataip]" is only supported on source URIs
def parseFile(uri_org, src_or_dst):
    uri = re.sub("^file:", "", uri_org)
    rv = URI.makeURI(src_or_dst, media_type.FILE)

    # the host/port/dataip is between the leading double slash and the third
    # slash
    mo = re.match(r"//([^/]*)/", uri)
    if not mo:
        raise RuntimeError, "{0}: invalid - does not match //.../".format(uri_org)
    hoststuff = mo.group(1)

    # now that we have matched the hoststuff out of it, we can take it out
    # of the URI
    p = re.sub(r"^//[^/]*", "", uri)

    # Did anyone mention start/end byte?
    p_split = p.split(':')
    rv.path = p_split[0]  # path is always the first bit - start/end is last (below)

    # On source file name we MUST have a filename
    if rv.direction==uri_type.SRC:
        if len(rv.path)<=1:
            raise RuntimeError, "{0}: source URI MUST have a file/path".format(uri_org)

    # Now parse the host/port stuff
    colonized = hoststuff.split(':')

    # Length check - at most three entries
    if len(colonized)>3:
        raise RuntimeError, "{0}: invalid 'host:port:dataip' part".format(uri_org)

    # Because we have the ":"'s separating the entries we only need to
    # verify if they exist at all
    rv.controlIP   = resolve_ip(OPTARG(colonized, 0, "localhost"))
    rv.controlPort = OPTARG(colonized, 1, controlport)
    if rv.controlPort:
        rv.controlPort = int(rv.controlPort)

    # Only source-type URI's parse the data ip;
    # so we only set the value if the URI object _has_ that
    # attribute
    dataip = OPTARG(colonized, 2)
    if dataip:
        if hasattr(rv, 'dataIP'):
            rv.dataIP = resolve_ip(dataip)
        else:
            raise RuntimeError, "{0} does support setting of dataip ({1})".format(uri_org, src_or_dst)

    # Save the start/end byte number parsing for last such that the URI is filled in
    rv.parseStartEndByte( OPTARG(p_split, 1), OPTARG(p_split, 2) )
    return rv

# 'vbs' is a vlbi-streamer recording on a flexbuff
#  at the moment this one does *not* support 'slicing', i.e.
#  no start/end byte specification
#
#   vbs://[host][:port][:dataip]/recording
#
# note that "[:dataip]" is only supported on source URIs
def parseVBS(uri_org, src_or_dst):
    uri = re.sub("^vbs:", "", uri_org)
    rv = URI.makeURI(src_or_dst, media_type.VBS)

    # the host/port/dataip is between the leading double slash and the third
    # slash
    mo = re.match(r"//([^/]*)/", uri)
    if not mo:
        raise RuntimeError, "{0}: invalid - does not match //.../".format(uri_org)
    hoststuff = mo.group(1)

    # now that we have matched the hoststuff out of it, we can take it out
    # of the URI
    rv.path = re.sub(r"^//[^/]*/", "", uri)

    # Did anyone mention start/end byte?
    # we do parse them so we can yell if we find 'm :D
    if rv.path.count(':'):
        raise RuntimeError, "{0}: VBS recordings do not support start/end byte".format(uri_org)

    # On source vbs we MUST have a recording name
    if rv.direction==uri_type.SRC:
        if not rv.path:
            raise RuntimeError, "{0}: source URI MUST have a recording name".format(uri_org)
        if rv.path.count('/'):
            raise RuntimeError, "{0}: recording name may not contain slashes".format(uri_org)

    # Now parse the host/port stuff
    colonized = hoststuff.split(':')

    # Length check - at most three entries
    if len(colonized)>3:
        raise RuntimeError, "{0}: invalid 'host:port:dataip' part".format(uri_org)

    # Because we have the ":"'s separating the entries we only need to
    # verify if they exist at all
    rv.controlIP   = resolve_ip(OPTARG(colonized, 0, "localhost"))
    rv.controlPort = OPTARG(colonized, 1, controlport)
    if rv.controlPort:
        rv.controlPort = int(rv.controlPort)

    # Only source-type URI's parse the data ip;
    # so we only set the value if the URI object _has_ that
    # attribute
    dataip = OPTARG(colonized, 2)
    if dataip:
        if hasattr(rv, 'dataIP'):
            rv.dataIP = resolve_ip(dataip)
        else:
            raise RuntimeError, "{0} does support setting of dataip ({1})".format(uri_org, src_or_dst)
    return rv



###########################
# VSI-S command/reply stuff
###########################

def split_reply(reply):
    end_index = reply.rfind(';')
    if end_index != -1:
        reply = reply[:end_index]
    separator_index = reply.find('=')
    if separator_index == -1:
        separator_index = reply.find('?')
        if separator_index == -1:
            return [reply]

    return map(lambda x: x.strip(), [reply[0:separator_index]] + reply[separator_index+1:].split(':'))

class Mark5(object):
    anyReturn = range(0,9)

    def __init__(self, address, port, timeout=5):
        self.timeout       = timeout
        self.connect_point = (address, port)
        self.socket        = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.settimeout(self.timeout)
        try:
            self.socket.connect(self.connect_point)
        except:
            raise RuntimeError, "Failed to connect to {0}".format(self.connect_point)
   
        # do we have jive5* running on that connection?
        self.program = self.get_program()
        if not re.search("^jive5", self.program):
            raise RuntimeError, "{0}:{1} is not running a version of jive5a(b(c))".format(address, port)
        self.save( ["net_protocol", "mtu", "ipd", "net_port"] )

    def get_type(self):
        return self.send_query("dts_id?")[2]

    def get_program(self):
        # this query should only return "0", not even "1"!
        return self.send_query("version?", [0])[2]

    def send_query(self, query, acceptable_codes=[0,1], timeout=None):
        if queries:
            print self.connect_point,":",query
        if timeout and timeout!=self.timeout:
            self.socket.settimeout(timeout)
        self.socket.send(query + "\n\r")
        reply = split_reply(self.socket.recv(1024))
        self.socket.settimeout(self.timeout)
        if not int(reply[1]) in acceptable_codes:
            raise RuntimeError, "Unacceptable return code {0} from query '{1}' - {2}".format(int(reply[1]), query, reply)
        return reply

    def save(self, cmdlist):
        self.prevState = dict(zip(cmdlist, map(lambda x: self.send_query(x+"?", [0]), cmdlist)))

    def restore(self):
        for (k,v) in self.prevState.iteritems():
            self.send_query(k+"="+":".join(v[2:]))

    def location(self):
        return ":".join(map(str, self.connect_point))

    ## attempt to switch to bank 'bank' on the Mark5
    ## indicated by 'ctrl', assumed to be a 'Mark5' object
    def switch_bank(self, bank):
        bank    = bank.upper()
        actbank = self.send_query("bank_info?")[2].upper()
        if actbank!=bank:
            # issue the bank switch command
            reply = self.send_query("bank_set={0}".format(bank), [1])
            # wait for it to complete
            while True:
                time.sleep(1)
                reply = self.send_query("bank_set?", [0, 6])
                if reply[1]=="0":
                    break
            # verify it's a different bank than we started with
            if actbank==reply[2].upper():
                reply = self.send_query("error?")
                raise RuntimeError, "{0} could not switch to bank {1} [{2}]".format(self.location(), bank, ":".join(reply[3:]))
        return actbank

    # Attempt to switch to the bank containing the indicated VSN
    def switch_vsn(self, vsn):
        vsn = vsn.upper()

        # query which VSNs are currently loaded
        #  0          1   2       3         4       5
        #  !bank_set? 0 : [AB-] : <vsn>|- : [BA-] : <vsn>|- ;
        # Create a mapping of VSN => bank
        reply = self.send_query("bank_set?", [0])
        def proc_entry(acc, idx):
            # extract [<bank>, <vsn>]
            sel = reply[idx:idx+2]
            # if bank or vsn == '-': 
            #     'inactive bank' or 'no module loaded'
            if not "-" in sel:
                # Note: <vsn> is typically  <vsn>/<capacity>/<speed>
                acc[ sel[1].upper().split('/')[0] ] = sel[0].upper()
            return acc
        vsnbankmap = reduce(proc_entry, [2,4], {})
        if not vsn in vsnbankmap:
            raise RuntimeError, "{0} VSN {1} not found on this machine".format(self.location(), vsn)
        return self.switch_bank(vsnbankmap[vsn])


########################
## base class for a xfer
########################


class DataSource(object):
    def __init__(self, src):
        self.source  = src
        self.control = Mark5(self.source.controlIP, self.source.controlPort)
        self.control.send_query("mode=none", [0])

    # must return a list of source paths
    def __iter__(self):
        raise RuntimeError, "N/A"
    def __next__(self):
        raise RuntimeError, "N/A"


class DataSink(object):
    def __init__(self, dst):
        self.destination = dst
        self.control = Mark5(self.destination.controlIP, self.destination.controlPort)
        self.control.send_query("mode=none", [0])


## Mark5 disk pack as source
class DiskSource(DataSource):
    def __init__(self, location):
        super(DiskSource, self).__init__(location)

        CTRL = self.control
        SRC  = self.source

        # Select the requested bank or VSN, if one was given.
        # Note: bank and VSN are mutually exclusive at most one
        #       of them is actually set
        if SRC.bank:
            CTRL.switch_bank(SRC.bank)
        if SRC.VSN:
            CTRL.switch_vsn(SRC.VSN)

        # Look at the location - if it's made out of numbers, dashes and commas
        # it's a list of scan numbers, otherwise a scan name(s)
        rxNums = re.compile(r"^([0-9]+(-[0-9]+)?)(,([0-9]+(-[0-9]+)?))*$")

        filter_f = None
        if SRC.path=="*":
            # Short circuit for all scans
            filter_f = lambda x : True
        elif rxNums.match(SRC.path):
            scanids = set(expand_string_range(SRC.path, '-'))
            filter_f = lambda (num, name): num in scanids
        else:
            # replace "*" by ".*" and "?" by "."
            path     = sub(SRC.path, [("\.","\."), ("\*", ".*"), ("\+", "\+"), ("\?",".")])
            scanname = re.compile(r"^"+path+"$")
            filter_f = lambda (num, name): scanname.match(name)

        # Get the list of scans and immediately filter them
        nscan    = int(CTRL.send_query("dir_info?", [0])[2])

        def get_scan(i):
            CTRL.send_query("scan_set={0:d}".format(i), [0])
            r = CTRL.send_query("scan_set?", [0])
            if int(r[2])!=i:
                raise RuntimeError, "Scan {0} failed to set".format(i)
            return (i, r[3])

        self.scanList = filter(filter_f, map(get_scan, xrange(1, nscan+1)))


    # implement the DataSource part
    def __iter__(self):
        return iter(self.scanList)

    def __len__(self):
        return len(self.scanList)


class FileSource(DataSource):
    def __init__(self, location):
        super(FileSource, self).__init__(location)

        # we cannot retrieve the list of files remotely
        # but only locally
        CTRL = self.control
        SRC  = self.source
        self.pathList = [SRC.path]

        # do we need to do wildcard processing?
        if '*' in SRC.path or '?' in SRC.path:
            if SRC.controlIP != '127.0.0.1':
                raise RuntimeError, "Unfortunately we do not support wildcards in file names on remote systems"
            # Check if path contains wildcards. Only allow those
            # in the file name part
            (dir, file) = os.path.split( SRC.path )
            if '*' in dir or '?' in dir:
                raise RuntimeError, "Wildcards not allowed in directory names"
            # we now know that the wildcard, if present, must reside in the file part
            # replace "*" by ".*" and "?" by "." in the file name
            # (also escape regex special chars)
            file     = sub(file, [("\.", "\."), ("\*", ".*"), ("\+", "\+"), ("\?",".")])
            filename = re.compile(r"^"+file+"$")
            # Only consider files located in 'dir'
            self.pathList = []
            for (root, dirs, files) in os.walk(dir):
                if root!=dir:
                    dirs = []
                    continue
                # use the reduce structure such that we do not _overwrite_ self.pathList
                # but append to it
                self.pathList = reduce( \
                    lambda acc, p: acc+[os.path.join(root,p)] if filename.match(p) else acc, \
                    files, self.pathList )

    def __iter__(self):
        return iter(self.pathList)

    def __len__(self):
        return len(self.pathList)


class VBSSource(DataSource):
    def __init__(self, location):
        super(VBSSource, self).__init__(location)

        SRC  = self.source
        self.pathList = [SRC.path]
        # do we need to do wildcard processing?
        if '*' in SRC.path or '?' in SRC.path:
            if SRC.controlIP != '127.0.0.1':
                raise RuntimeError, "Unfortunately we do not support wildcards in file names on remote systems"
            # Note: the parseVBS has already guaranteed that the path
            # contains no slashes. Do regex special char escaping as well
            # as translating "*" into ".*" and "?" into "."
            path     = copy.copy(SRC.path)
            path     = sub(path, [("\.", "\."), ("\*", ".*"), ("\+", "\+"), ("\?",".")])
            rxRecord = re.compile(r"^"+path+"$")
            rxDisk   = re.compile(r"^disk[0-9]+$")
            rxRecDir = re.compile(r"^/mnt/disk[0-9]+$")
            rxPath   = re.compile(r"^/mnt/disk[0-9]+/(?P<recording>"+path+")$")
            rxFile   = re.compile(r"^"+path+"\.[0-9]{8}$")

            # On the FlexBuff all recordings reside under 
            # /mnt/disk[0-9]+/<recording>
            # Maybe we should filter out only the recordings (1) matching
            # the pattern (d'oh) but also those that actually contain
            # *data*!
            # vlbi_streamer data files are found:
            #   /mnt/disk[0-9]+/<recording>/<recording>.[0-9]{8} 
            #  i.e. files with basename <recording> and an 8-digit sequence
            #  number
            recordingset  = set()
            for (root, dirs, files) in os.walk("/mnt"):
                # in "/mnt" we only consider the "dirs" that match the
                # "disk[0-9]+"
                if root=="/mnt":
                    dirs = filter(lambda x: rxDisk.match(x), dirs)
                    continue
                # In <root>'s matching "/mnt/disk[0-9]+", we only 
                # consider "dirs" that match the recording
                if rxRecDir.match(root):
                    dirs = filter(lambda x: rxRecord.match(x), dirs)
                    continue
                # In <root>'s actually matching
                # /mnt/disk[0-]+/<recording>/ we look for
                # files matching "<recording>.[0-9]{8}"
                mo = rxPath.match(root)
                if mo:
                    # if we find any files matching, the recording
                    # can be added
                    if len(filter(lambda x: rxFile.match(x), files)):
                        recordingset.add( mo.group('recording') )
            self.pathList = list(recordingset)

    def __iter__(self):
        return iter(self.pathList)

    def __len__(self):
        return len(self.pathList)

class FileDest(DataSink):
    def __init__(self, location):
        super(FileDest, self).__init__(location)

        # not a lot to do here ...


class DiskDest(DataSink):
    def __init__(self, location):
        super(DiskDest, self).__init__(location)

        CTRL = self.control
        DST  = self.destination

        # Select the requested bank or VSN, if one was given.
        # Note: bank and VSN are mutually exclusive at most one
        #       of them is actually set
        if DST.bank:
            CTRL.switch_bank(DST.bank)
        if DST.VSN:
            CTRL.switch_vsn(DST.VSN)

class VBSDest(DataSink):
    def __init__(self, location):
        super(VBSDest, self).__init__(location)



# local disk2file transfer
def disk2file(d, f):
    # verify that destination refers to a DIR if we have >1 scans
    (dir, file) = os.path.split(f.destination.path)

    if len(d)>1 and len(file):
            raise RuntimeError, "{0}: is a file not a directory (>1 scans to transfer)".format(f.destination.path)

    # create some shorthands
    CTRL      = d.control
    startByte = d.source.startByte
    endByte   = d.source.endByte

    try:
        for (num, name) in d:
            # if the output path was a directory, do append the scan name
            outfile = f.destination.path + ((name + ".m5a") if not file else "")
            print name," => ",outfile
            CTRL.send_query("scan_set={0:d}".format(num), [0])
            # Assert the scan set correctly. Also, this gives us the initial
            # scan start/end values
            reply = CTRL.send_query("scan_set?", [0])
            if not (int(reply[2])==num and reply[3]==name):
                raise RuntimeError, "Scan #{0} ({1}) is not that anymore, it is now #{2} ({3})".format(num, name, int(reply[2]), reply[3])

            progress_meter = Progress(45)
            # Now form the command
            CTRL.send_query("disk2file={0}:{1}:{2}:{3}".format( outfile, \
                    startByte if startByte else "", endByte if endByte else "", \
                    'w' if outfile=="/dev/null" else 'n'), [1])
            # wait for completion
            while True:
                r = CTRL.send_query("disk2file?")
                if r[2]=="inactive":
                    break
                if verbose:
                    progress_meter(int(r[5]), int(r[4]), int(r[6]))
                time.sleep(1)
            if verbose:
                progress_meter.done()
    finally:
        CTRL.send_query("reset=abort", Mark5.anyReturn)

def file2disk(f, d):
    # the destination disk may not refer to a specific scan name if 
    # there's >1 source files
    if len(f)>1:
        if len(d.destination.path):
            raise RuntimeError, "{0}: specifies one destination scan name whilst >1 source files".format(d.destination.path)

    CTRL      = f.control
    startByte = f.source.startByte
    endByte   = f.source.endByte
    try:
        for p in f:
            (dir, file) = os.path.split(p)
            if len(file)==0:
                raise RuntimeError, "{0}: not a file but a directory!".format(p)
            # strip extension
            scanname = os.path.splitext(file if not d.destination.path else d.destination.path)[0]
            print p," => ",(d.destination.bank+"::" if d.destination.bank else ""), scanname

            progress_meter = Progress(45)
            CTRL.send_query("file2disk={0}:{1}:{2}:{3}".format(p, (startByte if startByte else ""), (endByte if endByte else ""), scanname), [1])
            # wait for completion
            while True:
                r = CTRL.send_query("file2disk?")
                if r[2]=="inactive":
                    break
                if verbose:
                    progress_meter(int(r[5]), int(r[4]), int(r[6]))
                time.sleep(1)
            if verbose:
                progress_meter.done()
    finally:
        CTRL.send_query("reset=abort", Mark5.anyReturn)



##### lcl transfers only allowed if media are different
def lcl_xfer(src, dst):
    if src.mediaType==dst.mediaType or \
       src.mediaType==media_type.VBS or \
       dst.mediaType==media_type.VBS:
        raise ValueError, "Unsupported local transfer {0} -> {1}".format(src.mediaType,\
                                                                         dst.mediaType)
    matrix = {
        (media_type.DISK, media_type.FILE): (disk2file, DiskSource, FileDest),
        (media_type.FILE, media_type.DISK): (file2disk, FileSource, DiskDest)
    }
    (f, s, d) = matrix[ (src.mediaType, dst.mediaType) ]
    return f(s(src), d(dst))


def disk2net2disk(d_src, d_dst):
    # verify that destination does not refer to just a single scan
    if len(d_src)>1:
        if len(d_dst.destination.path):
            raise RuntimeError, "{0}: specifies one destination scan name whilst >1 source scans".format(d_dst.destination.path)

    # set net_protocol on both systems
    SRC       = d_src.source
    DST       = d_dst.destination
    SRC_C     = d_src.control
    DST_C     = d_dst.control
    dataIP    = SRC.dataIP if hasattr(SRC, 'dataIP') and SRC.dataIP else DST.controlIP
    sendAll   = lambda c, r: map(lambda x: x.send_query(c, r), [SRC_C, DST_C])

    sendAll("net_protocol={0:s}:64M:2M".format(protocol), [0])
    sendAll("mtu={0:d}".format(mtu), [0])
    sendAll("net_port={0:d}".format(dataport), [0])
    
    try:
        # process all scans
        for (num, name) in d_src:
            # make sure the scan set correctly and that it still is the
            # scan name we expect [someone may have switched disk pack off]
            SRC_C.send_query("scan_set={0:d}".format(num), [0])
            reply = SRC_C.send_query("scan_set?", [0])
            if not (int(reply[2])==num and reply[3]==name):
                raise RuntimeError, "Scan #{0} ({1}) is not that anymore, it is now #{2} ({3})".format(num, name, int(reply[2]), reply[3])
            scanname = d_dst.destination.path if d_dst.destination.path else name
            print "{0}::{1}{2} => {3}::{4}{5}".format( \
                    SRC.controlIP, (SRC.bank+"/" if hasattr(SRC, 'bank') and SRC.bank else ""), name, \
                    DST.controlIP, (DST.bank+"/" if hasattr(DST, 'bank') and DST.bank else ""), scanname)
            DST_C.send_query("net2disk=open:{0:s}".format(scanname), [0])
            SRC_C.send_query("disk2net=connect:{0:s}".format(dataIP), [0])
            progress_meter = Progress(45)
            SRC_C.send_query("disk2net=on:{0}:{1}".format( SRC.startByte if SRC.startByte else "", SRC.endByte if SRC.endByte else ""), [0])

            # wait for completion
            while True:
                r = SRC_C.send_query("disk2net?")
                if r[2]=="inactive":
                    break
                if verbose:
                    progress_meter(int(r[5]), int(r[4]), int(r[6]))
                time.sleep(1)
            if verbose:
                progress_meter.done()
            # close remote end. somehow, when using udt, this may take a
            # while
            DST_C.send_query("net2disk=close", [0], timeout=10)
    finally:
        # basically we just call these always ... even if succesfull return
        SRC_C.send_query("disk2net=disconnect", Mark5.anyReturn)
        DST_C.send_query("net2disk=close", Mark5.anyReturn, timeout=10)





def disk2net2file(d_src, f_dst):
    # verify that destination refers to a DIR if we have >1 scans
    (dir, file) = os.path.split(f_dst.destination.path)

    if len(d_src)>1 and len(file):
            raise RuntimeError, "{0}: is a file not a directory (>1 scans to transfer)".format(f_dst.destination.path)

    # set net_protocol on both systems
    SRC       = d_src.source
    DST       = f_dst.destination
    SRC_C     = d_src.control
    DST_C     = f_dst.control
    dataIP    = SRC.dataIP if hasattr(SRC, 'dataIP') and SRC.dataIP else DST.controlIP
    sendAll   = lambda c, r: map(lambda x: x.send_query(c, r), [SRC_C, DST_C])

    sendAll("net_protocol={0:s}:64M:2M".format(protocol), [0])
    sendAll("mtu={0:d}".format(mtu), [0])
    sendAll("net_port={0:d}".format(dataport), [0])
    
    try:
        # process all scans
        for (num, name) in d_src:
            # make sure the scan set correctly and that it still is the
            # scan name we expect [someone may have switched disk pack off]
            SRC_C.send_query("scan_set={0:d}".format(num), [0])
            reply = SRC_C.send_query("scan_set?", [0])
            if not (int(reply[2])==num and reply[3]==name):
                raise RuntimeError, "Scan #{0} ({1}) is not that anymore, it is now #{2} ({3})".format(num, name, int(reply[2]), reply[3])
            # if the output path was a directory, do append the scan name
            outfile = f_dst.destination.path + ((name + ".m5a") if not file else "")
            print "{0}::{1}{2} => {3}::{4}".format( \
                    SRC.controlIP, (SRC.bank+"/" if hasattr(SRC, 'bank') and SRC.bank else ""), name, \
                    DST.controlIP, outfile)
            DST_C.send_query("net2file=open:{0:s},{1}".format(outfile, 'w' if outfile=="/dev/null" else 'n'), [0])
            SRC_C.send_query("disk2net=connect:{0:s}".format(dataIP), [0])
            progress_meter = Progress(45)
            SRC_C.send_query("disk2net=on:{0}:{1}".format(SRC.startByte if SRC.startByte else "", SRC.endByte if SRC.endByte else ""), [0])

            # wait for completion
            while True:
                r = SRC_C.send_query("disk2net?")
                if r[2]=="inactive":
                    break
                if verbose:
                    progress_meter(int(r[5]), int(r[4]), int(r[6]))
                time.sleep(1)
            if verbose:
                progress_meter.done()
            # close remote end
            DST_C.send_query("net2file=close", [0])
    finally:
        # basically we just call these always ... even if succesfull return
        SRC_C.send_query("disk2net=disconnect", Mark5.anyReturn)
        DST_C.send_query("net2file=close", Mark5.anyReturn)




def file2net2disk(f_src, d_dst):
    # verify that destination does not refer to just a single scan
    if len(f_src)>1:
        if len(d_dst.destination.path):
            raise RuntimeError, "{0}: specifies one destination scan name whilst >1 source files".format(d_dst.destination.path)

    # set net_protocol on both systems
    SRC     = f_src.source
    DST     = d_dst.destination
    SRC_C   = f_src.control
    DST_C   = d_dst.control
    dataIP  = SRC.dataIP if hasattr(SRC, 'dataIP') and SRC.dataIP else DST.controlIP
    sendAll = lambda c, r: map(lambda x: x.send_query(c, r), [SRC_C, DST_C])

    sendAll("net_protocol={0:s}:64M:2M".format(protocol), [0])
    sendAll("mtu={0:d}".format(mtu), [0])
    sendAll("net_port={0:d}".format(dataport), [0])

    try:
        # process all scans
        for p in f_src:
            (dir, file) = os.path.split(p)
            if len(file)==0:
                raise RuntimeError, "{0}: not a file but a directory!".format(p)
            # strip extension
            scanname = os.path.splitext(file if not d_dst.destination.path else d_dst.destination.path)[0]
            print "{0}::{1} => {2}::{3}{4}".format( \
                    SRC.controlIP, p, \
                    DST.controlIP, (DST.bank+"/" if hasattr(DST, 'bank') and DST.bank else ""), scanname)
            DST_C.send_query("net2disk=open:{0:s}".format(scanname), [0])
            SRC_C.send_query("file2net=connect:{0:s}:{1:s}".format(dataIP, p), [0])
            progress_meter = Progress(45)
            SRC_C.send_query("file2net=on:{0}:{1}".format((SRC.startByte if SRC.startByte else ""), (SRC.endByte if SRC.endByte else ""), scanname), [0])

            # wait for completion
            while True:
                r = SRC_C.send_query("file2net?")
                if r[2]=="inactive":
                    break
                if verbose:
                    progress_meter(int(r[5]), int(r[4]), int(r[6]))
                time.sleep(1)
            if verbose:
                progress_meter.done()
            # close remote end
            DST_C.send_query("net2disk=close", [0], timeout=10)
    finally:
        SRC_C.send_query("file2net=disconnect", Mark5.anyReturn)
        DST_C.send_query("net2disk=close", Mark5.anyReturn, timeout=10)



def file2net2file(f_src, f_dst):
    # verify that destination refers to a DIR if we have >1 scans
    (ddir, dfile) = os.path.split(f_dst.destination.path)

    if len(f_src)>1 and len(dfile):
            raise RuntimeError, "{0}: is a file not a directory (>1 scans to transfer)".format(f_dst.destination.path)

    # set net_protocol on both systems
    SRC     = f_src.source
    DST     = f_dst.destination
    SRC_C   = f_src.control
    DST_C   = f_dst.control
    dataIP  = SRC.dataIP if hasattr(SRC, 'dataIP') and SRC.dataIP else DST.controlIP
    sendAll = lambda c, r: map(lambda x: x.send_query(c, r), [SRC_C, DST_C])

    sendAll("net_protocol={0:s}:64M:2M".format(protocol), [0])
    sendAll("mtu={0:d}".format(mtu), [0])
    sendAll("net_port={0:d}".format(dataport), [0])

    try:
        # process all scans
        for p in f_src:
            (sdir, sfile) = os.path.split(p)
            if len(sfile)==0:
                raise RuntimeError, "{0}: not a file but a directory!".format(p)
            # if the output path was a directory, do append the file name
            outfile = f_dst.destination.path + (sfile if not dfile else "")

            print "{0}::{1} => {2}::{3}".format( SRC.controlIP, p, DST.controlIP, outfile)
            DST_C.send_query("net2file=open:{0:s},{1}".format(outfile, 'w' if outfile=="/dev/null" else 'n'), [0])
            SRC_C.send_query("file2net=connect:{0:s}:{1:s}".format(dataIP, p), [0])
            progress_meter = Progress(45)
            SRC_C.send_query("file2net=on:{0}:{1}".format(SRC.startByte if SRC.startByte else "", SRC.endByte if SRC.endByte else ""), [0])

            # wait for completion
            while True:
                r = SRC_C.send_query("file2net?")
                if r[2]=="inactive":
                    break
                if verbose:
                    progress_meter(int(r[5]), int(r[4]), int(r[6]))
                time.sleep(1)
            if verbose:
                progress_meter.done()
            # close remote end
            DST_C.send_query("net2file=close", [0])
    finally:
        SRC_C.send_query("file2net=disconnect", Mark5.anyReturn)
        DST_C.send_query("net2file=close", Mark5.anyReturn)


#### we support file -> vbs, disk -> vbs and vbs -> vbs
#### but not vbs -> *

def file2net2vbs(f_src, v_dst):
    # verify that destination does not refer to just a single scan
    if len(f_src)>1:
        if len(v_dst.destination.path):
            raise RuntimeError, "{0}: specifies one destination scan name whilst >1 source files".format(v_dst.destination.path)

    # set net_protocol on both systems
    SRC     = f_src.source
    DST     = v_dst.destination
    NOW     = datetime.datetime.now
    SRC_C   = f_src.control
    DST_C   = v_dst.control

    dataIP  = SRC.dataIP if hasattr(SRC, 'dataIP') and SRC.dataIP else DST.controlIP
    sendAll = lambda c, r: map(lambda x: x.send_query(c, r), [SRC_C, DST_C])

    sendAll("net_protocol={0:s}:128M:2M".format(protocol), [0])
    sendAll("mtu={0:d}".format(mtu), [0])
    sendAll("net_port={0:d}".format(dataport), [0])
    # at the recorder, configure >1 disk writers
    DST_C.send_query("record=nthread:1:4", [0])

    try:
        # process all scans
        for p in f_src:
            (dir, file) = os.path.split(p)
            if len(file)==0:
                raise RuntimeError, "{0}: not a file but a directory!".format(p)
            # strip extension
            scanname = os.path.splitext(file if not v_dst.destination.path else v_dst.destination.path)[0]
            print "{0}::{1} => {2}::{3}".format( \
                    SRC.controlIP, p, \
                    DST.controlIP, scanname)

            DST_C.send_query("record=on:{0:s}".format(scanname), [0])
            SRC_C.send_query("file2net=connect:{0:s}".format(dataIP), [0])
            progress_meter = Progress(45)
            SRC_C.send_query("file2net=on:{0}:{1}".format( SRC.startByte if SRC.startByte else "", SRC.endByte if SRC.endByte else ""), [0])

            # wait for completion
            while True:
                r = SRC_C.send_query("file2net?")
                if r[2]=="inactive":
                    break
                if verbose:
                    progress_meter(int(r[5]), int(r[4]), int(r[6]))
                time.sleep(1)
            if verbose:
                progress_meter.done()
            # close remote end
            DST_C.send_query("record=off", [0])
    finally:
        # basically we just call these always ... even if succesfull return
        SRC_C.send_query("file2net=disconnect", Mark5.anyReturn)
        DST_C.send_query("record=off", Mark5.anyReturn)

def disk2net2vbs(d_src, v_dst):
    # verify that destination does not refer to just a single scan
    if len(d_src)>1:
        if len(v_dst.destination.path):
            raise RuntimeError, "{0}: specifies one destination scan name whilst >1 source scans".format(v_dst.destination.path)

    # set net_protocol on both systems
    SRC     = d_src.source
    DST     = v_dst.destination
    NOW     = datetime.datetime.now
    SRC_C   = d_src.control
    DST_C   = v_dst.control

    dataIP  = SRC.dataIP if hasattr(SRC, 'dataIP') and SRC.dataIP else DST.controlIP
    sendAll = lambda c, r: map(lambda x: x.send_query(c, r), [SRC_C, DST_C])

    sendAll("net_protocol={0:s}:128M:2M".format(protocol), [0])
    sendAll("mtu={0:d}".format(mtu), [0])
    sendAll("net_port={0:d}".format(dataport), [0])
    # at the recorder, configure >1 disk writers
    DST_C.send_query("record=nthread:1:4", [0])

    try:
        # process all scans
        for (num, name) in d_src:
            # make sure the scan set correctly and that it still is the
            # scan name we expect [someone may have switched disk pack off]
            SRC_C.send_query("scan_set={0:d}".format(num), [0])
            reply = SRC_C.send_query("scan_set?", [0])
            if not (int(reply[2])==num and reply[3]==name):
                raise RuntimeError, "Scan #{0} ({1}) is not that anymore, it is now #{2} ({3})".format(num, name, int(reply[2]), reply[3])
            scanname = d_dst.destination.path if d_dst.destination.path else name
            print "{0}::{1}{2} => {3}::{4}".format( \
                    SRC.controlIP, (SRC.bank+"/" if hasattr(SRC, 'bank') and SRC.bank else ""), name, \
                    DST.controlIP, scanname)
            DST_C.send_query("record=on:{0:s}".format(scanname), [0])
            SRC_C.send_query("disk2net=connect:{0:s}".format(dataIP), [0])
            progress_meter = Progress(45)
            SRC_C.send_query("disk2net=on:{0}:{1}".format( SRC.startByte if SRC.startByte else "", SRC.endByte if SRC.endByte else ""), [0])

            # wait for completion
            while True:
                r = SRC_C.send_query("disk2net?")
                if r[2]=="inactive":
                    break
                if verbose:
                    progress_meter(int(r[5]), int(r[4]), int(r[6]))
                time.sleep(1)
            if verbose:
                progress_meter.done()
            # close remote end
            DST_C.send_query("record=off", [0])
    finally:
        # basically we just call these always ... even if succesfull return
        SRC_C.send_query("disk2net=disconnect", Mark5.anyReturn)
        DST_C.send_query("record=off", Mark5.anyReturn)


def vbs2net2vbs(v_src, v_dst):
    # set net_protocol on both systems
    SRC     = v_src.source
    DST     = v_dst.destination
    NOW     = datetime.datetime.now
    SRC_C   = v_src.control
    DST_C   = v_dst.control

    # verify!
    if DST.path:
        raise RuntimeError, "On VBS -> VBS transfers you cannot set the output recording name"

    dataIP  = SRC.dataIP if hasattr(SRC, 'dataIP') and SRC.dataIP else DST.controlIP
    sendAll = lambda c, r: map(lambda x: x.send_query(c, r), [SRC_C, DST_C])

    sendAll("net_protocol={0:s}:128M:2M".format(protocol), [0])
    sendAll("mtu={0:d}".format(mtu), [0])
    sendAll("net_port={0:d}".format(dataport), [0])
  
    # when configuring the number of readers/writers we make some
    # assumptions:
    #   * reading vbs disks is faster than writing (thus nDiskReader <
    #     nDiskWriter)
    #   * the number of netwriters == netreaders so they'll be a nice 
    #     balanced match
    # configure number of filereader + netwriters at the sending end
    #n_net = (1 if protocol=="udt" else 10)
    SRC_C.send_query("vbs2net=nthread:{0}:{1}".format(nthread+1, nthread))

    # configure number of netreaders + diskwriters at the receiving end
    DST_C.send_query("net2vbs=nthread:{0}:{1}".format(nthread, max(nthread+1, 8)))

    # Iterate over the recordings
    for r in v_src:
        try:
            print "{0}::{1} -> {2}::{3}".format(SRC.controlIP, r, DST.controlIP, r)
            DST_C.send_query("net2vbs=open", [0])
            SRC_C.send_query("vbs2net=connect:{0}:{1}".format(r, dataIP), [0])
            # now, for progress, there's not much we can do, at the moment
            # we don't know _how much_ there is to transfer. We can, however,
            # do "tstat=" and do the differencing ourselves
            r = SRC_C.send_query("tstat=")
            lastTime  = float(r[2])
            lastCount = int(r[5]) if len(r)>4 else 0 
            while True:
                r = SRC_C.send_query("tstat=")
                if r[3]=="no_transfer":
                    break
                if verbose:
                    t  = float(r[2])
                    c  = int(r[5])
                    dt = (t - lastTime)
                    if dt:
                        p = "Progress speed: {0} total xfer: {1}".format( \
                                sciprint(((c-lastCount)*8)/(t-lastTime), "bit/s", 1024), \
                                sciprint(c, "byte", 1024) )
                        progress_print(p+" "*10+"\r")
                    lastTime  = t
                    lastCount = c
                time.sleep(1)
        finally:
            progress_print("Disconnecting (may take a while)"+" "*50+"\r")
            SRC_C.send_query("vbs2net=disconnect", Mark5.anyReturn, timeout=30)
            DST_C.send_query("net2vbs=close", Mark5.anyReturn, timeout=10)



#### The remote transfers: *2net + net2*
# here the media may be identical
def remote_xfer(src, dst):
    matrix = {
        (media_type.DISK, media_type.DISK): (disk2net2disk, DiskSource, DiskDest),
        (media_type.DISK, media_type.FILE): (disk2net2file, DiskSource, FileDest),
        (media_type.FILE, media_type.DISK): (file2net2disk, FileSource, DiskDest),
        (media_type.FILE, media_type.FILE): (file2net2file, FileSource, FileDest),
        (media_type.FILE, media_type.VBS):  (file2net2vbs,  FileSource, VBSDest),
        (media_type.DISK, media_type.VBS):  (disk2net2vbs,  DiskSource, VBSDest),
        (media_type.VBS,  media_type.VBS):  (vbs2net2vbs,   VBSSource,  VBSDest),
    }
    (f, s, d) = matrix[ (src.mediaType, dst.mediaType) ]
    return f(s(src), d(dst))


def xfer_selector(src, dst):
    # we have a matrix of endpoints (disk->file, file->disk, etc)
    # and the source/destination ip addresses; now we 
    # decide which transfers to choose
    #  (e.g. "disk(local) -> file(local) => disk2file"
    #        "disk(X)     -> file(Y)     => disk2net + net2file"
    matrix = {
            True:  lcl_xfer,
            False: remote_xfer \
        }
    return matrix[ (src.controlIP == dst.controlIP and \
                    src.controlPort == dst.controlPort) ](src, dst)


# returns None if the argument wasn't present, tp(<value>) if it was
# (such that it will give an exception if e.g. you expect int but
#  the user didn't pass a valid int
def get_val(arg, tp=str):
    try:
        # is 'arg' given?
        aidx = sys.argv.index(arg)
        aval = None
        try:
            # attempt to extract the following value
            aval   = sys.argv[aidx+1]
        except IndexError:
            raise RuntimeError, "Mission optionvalue to {0}".format(arg)

        try:
            aval = tp(aval)
        except:
            raise RuntimeError, "optionvalue {0} for option {1} is not {2}".format(sys.argv[aidx+1], arg, repr(tp))
        # remove those arguments
        del sys.argv[aidx]
        del sys.argv[aidx]
        return aval
    except (ValueError) as E:
        # no 'arg' given, don't complain
        return None



##################
# the main program
##################

if __name__ == "__main__":
    print """$Id$
    copy VLBI data from somewhere to elsewhere
               (c) H. Verkouter
"""

    #########################
    ## Check command line
    #########################

    # Was '-h' requested?
    if len(sys.argv)==1 or '-h' in sys.argv:
        usage()
        sys.exit( 0 )

    # before actually starting to process the args ... we must find the "-p
    # <port>" and extract it manually (the alternative would be to say
    # "p=<port>" but that's a bit ugly and looks too much like dd(1).
    p = get_val('-p', int)
    if p:
        dataport = p
    m = get_val('-m', int)
    if m:
        mtu = m
    n = get_val('-n', int)
    if n:
        nthread = n

    # Split remaining commandline in options and arguments
    (opts, args) = partition(lambda x: re.match("^-", x), sys.argv[1:])

    # require two arguments
    if len(args)!=2:
        usage()
        sys.exit( 1 )

    # UDT requested?
    if '-udt' in opts:
        protocol="udt"

    if '-v' in opts:
        verbose=True

    if '-q' in opts:
        queries=True

    # Note: we've already checked that there's exactly two arguments!
    src = parseURI(args[0], uri_type.SRC)
    dst = parseURI(args[1], uri_type.DST)

    if verbose:
        print src," ===> ",dst

    xfer_selector(src, dst)
